import os
import numpy as np
import pandas as pd
import subprocess
import argparse
import psutil
import time
import typing as T
from typing import Optional, Union, List, Tuple, Dict
from pathlib import Path
from concurrent.futures import ProcessPoolExecutor, as_completed

import utils as au

"""
Calculate structural properties of protein backbones generated by evaluated methods.

Two types of structural properties are supported currently:
1. Secondary Structure Elements
2. Radius of gyration. 
"""

def structural_analysis(
    input_csv: str,
    max_workers: int,
    cpu_threshold: float 
) -> pd.DataFrame:
    df = pd.read_csv(input_csv)
    new_columns = ['alpha_composition', 'beta_composition', 'coil_composition', 'turn_composition', 'Rg']
    for col in new_columns:
        df[col] = np.nan
        
    futures = {}
    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        process_id = 0
        for backbone_path in df['backbone_path'].unique():
            if df.loc[df['backbone_path'] == backbone_path, new_columns].isna().all(axis=1).any():
                while psutil.cpu_percent(interval=1) > cpu_threshold:
                    time.sleep(0.5)
                    
                method = df[df['backbone_path'] == backbone_path]['method'].iloc[0]
                path = backbone_path
                atom_part = 'backbone'

                if method == 'Genie':
                    # Find the row with the highest tm_score for this backbone_path
                    highest_tm_row = df[df['backbone_path'] == backbone_path].nlargest(1, 'tm_score')
                    path = highest_tm_row['sample_path'].iloc[0]
                    atom_part = 'CA'

                future = executor.submit(process_path, path, atom_part, process_id)
                futures[future] = (backbone_path, path, atom_part)
                process_id += 1
                
        for future in as_completed(futures):
            results = future.result()
            backbone_path, path, atom_part = futures[future]
            df.loc[df['backbone_path'] == backbone_path, new_columns] = results
    
    return df

def process_path(path: str, atom_part: str, process_id: int) -> List[float]:
    sse_results = au.calculate_secondary_structure(path)
    rg = au.radius_of_gyration(path, atom_part)
    print(sse_results, rg)
    return sse_results[1:] + [rg]  # Ignore the SSE format string

def create_parser():
    parser = argparse.ArgumentParser(description='Calculating pdb-TM(novelty) for protein backbones')
    parser.add_argument(
        '-i',
        '--input',
        type=str,
        help='Input csv file'
    )
    parser.add_argument(
        '-o',
        '--output',
        type=str,
        default='novelty_results.csv',
        help='Output csv file',
    )
    return parser
    
if __name__ == "__main__":
    parser = create_parser()
    args = parser.parse_args()
    
    if args.input is not None:
        # Check hardware status
        num_cpu_cores = os.cpu_count()
        
        results = structural_analysis(
            input_csv=args.input,
            max_workers=num_cpu_cores,
            cpu_threshold=75.0
        )
        results.to_csv(args.output, index=False)
